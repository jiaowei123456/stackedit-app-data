# TWIN V2: Scaling Ultra-Long User Behavior Sequence Modeling for Enhanced CTR Prediction at Kuaishou
[原文链接]()
## 0 摘要：
在大规模推荐系统中，为点击率预测任务建立长期用户兴趣模型的重要性正逐渐受到研究人员和从业者的重视。现有的工作，如 SIM 和 TWIN，通常采用两阶段方法来对与目标项相关的长期用户行为序列进行建模，这是出于效率方面的考虑。第一阶段使用基于搜索的机制（即通用搜索单元 GSU）从长序列中快速检索与目标项相关的子序列，而第二阶段则使用精确搜索单元（ESU）对检索结果进行计算以得出兴趣得分。鉴于用户行为序列的长度跨越整个生命周期，规模可能高达 $10^6$，目前还没有有效的解决方案能够完全建模如此庞大的用户兴趣。为了克服这一问题，我们引入了 TWIN-V2，这是对 TWIN 的改进版本，其中应用了分而治之的方法来压缩生命周期行为并揭示更准确和多样化的用户兴趣。具体而言，一种**层次聚类方法**在离线阶段会将具有相似生命周期行为特征的项目归为一个单一的聚类组。通过限制聚类的规模，我们能够将行为序列压缩到远远小于 $10^5$ 的规模，从而在 GSU 检索的在线推理中实现可管理的长度。**具有聚类意识的目标关注机制能够提取用户全面且多方面的长期兴趣，从而使最终的推荐结果更加准确和多样化**。在数十亿规模的工业数据集上进行的大量离线实验以及在线 A/B 测试证明了 TWIN-V2 的有效性。在高效的部署框架下，TWIN-V2 已成功部署到快手为数亿日活跃用户提供服务的主要流量中。

## 背景
例如，SIM、ETA 和 SDIM 可以过滤历史行为，但最长只能达到 103 个。TWIN 将最长长度扩展到了 104 到 105 级别。在部署过程中，TWIN 会利用最近的 10，000 个行为作为 GSU 的输入。不幸的是，这 10，000 个行为仅涵盖了快手应用程序中用户在过去 3-4 个月内的历史记录，未能涵盖用户行为的整个生命周期。

## 1 论文解决的问题：
我们分析了过去三年内快手应用程序中的用户行为。中高用户群体在过去三年中可以观看 $10^4$ 到$10^6$个视频，占该应用程序使用时长的大部分（60% + 35% = 95%）。因此，对整个生命周期进行建模是必要的。

## 2 论文创新点：
为解决这一问题，我们提出了 TWIN-V2，这是对 TWIN 的改进，使其能够模拟用户行为的整个生命周期。TWIN-V2 采用分而治之的方法，将整个生命周期的历史分解为不同的集群，并利用这些集群来模拟用户的长期兴趣。具体而言，我们将模型分为两个部分：离线部分和在线部分。**在离线部分，我们使用层次聚类将生命周期行为中的相似项目聚合成集群，并从每个集群中提取特征以形成虚拟项目。在在线部分，我们利用基于聚类行为的集群感知目标注意力来提取长期兴趣。在此，注意力得分会根据相应的集群大小进行重新加权**。大量的实验表明，TWIN-V2 在各种类型的用户中都提高了性能，从而产生了更准确和多样化的推荐结果。

### 2.1 Hierarchical Clustering Over Life Cycle (生命周期层次聚类)
对于用户 u 而言，我们将其所有历史行为表示为一个项目序列 S = [s1， s2， · · · ， sT]，其中 T 是生命周期行为的数量，s j 是第 j 个交互项目。用户可能会在 S 中观看许多相似的视频。例如，一个喜欢 NBA 比赛的用户在其历史记录中可能会有数百个与篮球相关的视频。因此，一个自然的想法是将 S 中相似的项目聚合到簇中，使用一个单一的簇来代表许多相似的项目，从而减少 T 的大小。正式地说，我们的目标是使用压缩函数 hcomp 将长度为 T 的行为序列 S 减少为长度为 Tˆ 的序列 C：
当 Tˆ ≪ T 时。设 C 表示聚类行为，C = [c1， c2， · · · ， cTˆ ] ，其中 ci 表示包含聚类项目的第 i 个集合。具体而言，我们采用层次聚类方法来实现 hcomp，如算法 1 所示。在第一步中，我们简单地将历史行为分组。我们首先根据用户 u 播放该行为的时间比例（记为 p j = 视频播放时间 视频总时长 对于第 j 个行为项 s j 的表示）将历史项目分类为 M 个不同的组。在第二步中，我们递归地对每个组的生命周期历史行为进行聚类，直到每个聚类中的项目数量不超过 γ 。我们使用广泛使用的 k 均值方法（具有自适应聚类大小 γ）对从推荐模型获得的行为嵌入 Ks 进行聚类。γ 是一个超参数，用于控制最大聚类大小。
#### 2.1.1 Item分组
对用户生命长度的长序列的各个视频, 基于用户历史播放进度分成M组(快手这里),分组策略可以是等宽分组。事先对这些视频做分组是非常有必要的, 用户对不同视频的快滑或完播行为反映了用户对不同视频的不同兴趣浓度, 按播放进度分组后再做聚类, 这样簇内的Item在播放进度这一指标上是保持一致的, 更具有一定的内聚性。
#### 2.1.2 层次聚类
1.  **初始化一个空列表 C**：
    创建一个空列表 C，用于存储最终的聚类结果。
2.  **外层循环：遍历从 1 到 M 的每个 m**：
    对于每一个 m，执行以下操作。
3.  **初始化一个空队列 Q**：
    创建一个空队列 Q，用于存储待处理的集合。
4.  **将 Lm加入队列 Q**：
    将当前的集合 Lm加入队列 Q 中。
5.  **内层循环：当队列 Q不为空时**：
    只要队列 Q 中还有元素，就继续执行以下操作。
6.  **从队列 Q 中取出一个集合 V**：
    从队列 Q中取出一个集合 V进行处理。
7.  **判断集合 V的大小是否小于阈值 γ**：
    如果集合 V的大小 ∣V∣小于阈值 γ，则将 V直接添加到结果列表 C中。
    否则，继续执行下一步。
8.  **计算分组数 δ**：
    计算分组数 δ，其值为 ∣V∣0.3，即集合 V大小的 0.3 次方并向下取整。
9.  **对集合 V进行 K-means 聚类**：
    使用 K-means 算法将集合 V分成 δ个子集 J1,J2,…,Jδ，聚类的依据是这些元素在 Ks 中对应的嵌入。
10.  **将每个子集 Ji加入队列 Q**：
    将通过 K-means 聚类得到的每个子集 Ji 重新加入队列 Q 中，以便进一步处理。
11.  **结束内层循环**：
    当队列 Q为空时，结束内层循环。
12.  **结束外层循环**：
    当所有 m都处理完毕后，结束外层循环。
13.  **返回结果列表 C**：
    返回最终的聚类结果列表 C
    
这个算法通过递归地对集合进行 K-means 聚类，直到每个子集的大小小于预设的阈值 γ，从而实现层次聚类。最终的结果是一个包含所有满足条件的子集的列表 C。
**思考**：这里的V就是Lm(list M)，相当于依次将Lm传入判断集合大小与 γ关系，如果小就直接加入C中，如果大就计算要分的组数δ，然后通过emb进行聚类，并将这δ组再次判断大小，，最后保证所有组(后续称为簇)的大小都小于γ。
### 2.2 计算聚类后簇的表征
![输入图片说明](/imgs/2025-07-22/kmS9chOXIKr2VIu8.png)
### 2.3 聚类感知的Target Attention
在得到各个簇的表征后, 这些簇会参与后续GSU和ESU的Target Attention的计算。这里的Target Attention的实现基本和TWIN类似, 但需要把原来的Item部分换成聚类。
考虑到聚类后不同簇的大小可能不一, 上面相关性得分的计算上并没有考虑这一细节。因此, 作者这里在相关性得分的计算会做一些调整:
![输入图片说明](/imgs/2025-07-22/lLA91RYitjNV5BKw.png)
**思考**：这六
## 4 模型结构与实现代码：


## 5 实验与分析：

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc1MDE5MzA5LDEwNDYzMjc3ODgsLTI4OT
IyNTMzMiwtNTAwMzE0MDcsMTI0NzE1MTQ0OCwtOTgzNzEwNzky
LDg3MzkxNDI2MCwtNjI2MzQ2NTY5LC0yMTkwOTk4NjksLTE5MT
A1OTA3NDgsLTIzNTMwNTg0NywxNzE4MTU0NDcwXX0=
-->